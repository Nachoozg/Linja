


class Tablerolinja:
    
    def __init__(self, matrix):
        self.setMatrix(matrix)
        self.turno = 1
        self.numeroMovimiento = -1
        self.movimientoFila = 0
        self.movimiento = 0
        self.fichasFila = 0
        self.row_nueva = 0
        self.turnoExtra = False
    
    def __eq__(self, other) -> bool:  
        return self.getMatrix() == other.getMatrix()
    
    def __iter__(self):
        # Devuelve un iterador sobre la matriz
        return iter(self.matrix)
    
    def setMatrix(self, matrix):
        self.matrix = deepcopy(matrix)
    
    def getMatrix(self) -> List[List]:
        return deepcopy(self.matrix)
    
    
    def placeTile(self, row: int, col: int, tile: int):
        if 0 <= row < len(self.matrix) and 0 <= col < len(self.matrix[0]):
            self.matrix[row][col] = tile
            return 1  # Indica que la ficha fue colocada con éxito
        else:
            raise ValueError("No hay ficha en esa posición o estás eligiendo una fuera de los límites del tablero")
    

    def deleteTile(self, row: int, col: int):
        if 0 <= row < len(self.matrix) and 0 <= col < len(self.matrix[0]):
            self.matrix[row][col] = 0  # Se asume que 0 representa una posición vacía
            return 1  # Indica que la ficha fue eliminada con éxito
        else:
            raise ValueError("No hay ficha en esa posición o estás eligiendo una fuera de los límites del tablero")
    
    
    def utility(self) -> int:
        coste_positivo = [1, 2, 3, 5]
        coste_negativo = [-5, -3, -2, -1]

        total_utility_rojo = 0
        total_utility_negro = 0
       
        # Obtener la mitad del tablero
        mitad_tablero = len(self.matrix) // 2

        for i, fila in enumerate(self.matrix):
            for j, valor in enumerate(fila):
                if valor != 0:
                    if i < mitad_tablero:
                        total_utility_rojo += coste_negativo[i]
                    else:
                        total_utility_negro += coste_positivo[i - mitad_tablero]

        # Devolver la diferencia entre las puntuaciones de los jugadores
        return total_utility_rojo - total_utility_negro


    def isAvailable(self) -> List:
        # Inicializa una lista vacía llamada "disponible"
        disponible = []

        # Itera sobre las filas de la matriz
        for i, fila in enumerate(self.matrix):
            # Utiliza la función all para verificar si todos los elementos de la fila son iguales a cero
            if not all(j == 0 for j in fila):
                # Si al menos un elemento no es cero, agrega el índice de la fila a la lista "disponible"
                disponible.append(i)

        # Devuelve la lista de índices de filas donde al menos un elemento no es cero
        return disponible
    
    
    def numFichasEnFila(self, row ) -> int:
        numFichas = 0
        fila = self.matrix[row]
        for i in fila:
            if i != 0:
                numFichas += 1
        return numFichas
        
        
    def numMovs(self, row: int) -> int:
        max_num_movs = 0
        mejor_movimiento = -1

        # Recorre las filas disponibles y evalúa cuántas fichas hay en esa fila
        for i, fila in enumerate(self.matrix):
            if i != row:  # Evita considerar la fila actual
                num_fichas_en_fila = sum(1 for cell in self.matrix[i] if cell != 0)
                
                # Actualiza si encontramos un mejor movimiento
                if num_fichas_en_fila > max_num_movs:
                    max_num_movs = num_fichas_en_fila
                    mejor_movimiento = i
                    
        # Número entero con el mayor número de casillas que se desplazan con un segundo movimiento.
        return mejor_movimiento 
    
    
    def obtenerMov(self, row: int, col: int, playerID: int, numMov: int, numFilasSeg: int) -> List[List]:
        # Realiza el movimiento permitido en función del número de fichas en la fila
        tablero_simulado = deepcopy(self)
        
        # Verifica que la fila sea válida y tiene al menos el número de fichas requerido
        if 0 <= row < len(tablero_simulado.matrix) and numMov > 0:
            # Calcula cuántas fichas hay actualmente en la fila
            num_fichas_en_fila = sum(1 for cell in tablero_simulado.matrix[row] if cell != 0)
            
            # Verifica si hay suficientes fichas para realizar el movimiento
            if num_fichas_en_fila >= numMov:
                # Coloca la ficha en la posición correspondiente
                tablero_simulado.placeTile(row, col, playerID)
                
                # Realiza el movimiento permitido
                tablero_simulado.moverFicha(row, col)
                
        return tablero_simulado.getMatrix()


    def cambiarTurno(self):
        if self.turno == 1: 
            self.turno = 2
        elif self.turno == 2:
            self.turno = 1


    def comprobarPosicion(self, row, col):
        # Verificar si la posición está dentro del tablero
        if row < 0 or row >= len(self.matrix) or col < 0 or col >= len(self.matrix[0]):
            return False
        # Verificar si la posición está vacía o tiene una ficha del mismo color
        if self.matrix[row][col] == 0 or self.matrix[row][col] == self.turno:
            return True
        # Verificar si la posición está en el extremo opuesto y tiene una ficha del color contrario
        if (row == 0 and self.matrix[row][col] == 2) or (row == len(self.matrix) - 1 and self.matrix[row][col] == 1):
            if self.matrix[row][col] == 1 - self.turno:
                return True
        # En cualquier otro caso, la posición no es válida
        return False
    
    
    def moverFicha(self, row, col):
        # Obtener la ficha en la posición actual
        ficha = self.matrix[row][col]
        
        # Verificar que la ficha en la posición actual coincide con el turno actual
        if ficha != 0 and ficha != self.turno:
            print("No puedes mover una ficha del otro jugador.")

        # Llamar al método correspondiente según el tipo de movimiento
        if self.movimiento == 0:
            # Llamar al primer movimiento y devolver el resultado
            resultado_movimiento = self.movimiento1(row, col)
        elif self.movimiento == 1:
            # Llamar al segundo movimiento y devolver el resultado
            resultado_movimiento = self.movimiento2(row, col)
        if self.finJuego():
            print("El juego ha terminado, no mueva más fichas")
            self.endGame()
        return resultado_movimiento
    
    
    def movimiento1(self, row, col):
        ficha = self.matrix[row][col]
        if ficha not in {1, 2}:
            print("No hay ficha en esa posición, elige otra en la que haya ficha.")
        # Calcular la nueva fila a la que se moverá la ficha
        # self.row_nueva = row + 1 if ficha == 1 else (row - 1 if ficha == 2 else row)
        if(row + 1 <= 7 and ficha == 1):
            self.row_nueva = row + 1
        elif(row - 1 >= 0  and ficha == 2):
            self.row_nueva = row - 1
        elif(row + 1 > 7 and ficha == 1):
            self.row_nueva = 7
        elif(row - 1 < 0 and ficha == 2):
            self.row_nueva = 0
        else:
            return 0
        # Verificar si el jugador no alcanzó el extremo opuesto
        if 0 <= self.row_nueva < len(self.matrix):
            col_nueva = col
            # Verificar si hay ficha en la fila de destino
            if self.matrix[self.row_nueva][col] != 0:
                col_candidata = col_nueva
                # Si hay ficha, desplaza lateralmente hacia la derecha o izquierda
                # Creo una variable booleana que indique si se ha encontrado una columna vacía
                encontrado = False
                i = 1  # Comenzar con el primer desplazamiento
                while i <= 5 and not encontrado:
                    col_candidata = col_nueva + i
                    # Verificar si la columna candidata está dentro del rango válido
                    if 0 <= col_candidata < len(self.matrix[0]):
                        # Verificar si la columna candidata está vacía
                        if self.matrix[self.row_nueva][col_candidata] == 0:
                            # Asignar la columna candidata a la variable col_nueva
                            col_nueva = col_candidata
                            # Cambiar el valor de la variable encontrado a True
                            encontrado = True
                            # Romper el bucle cuando se encuentre una columna vacía
                            break
                    i += 1
                i = 1  # Restablecer el valor de i para el desplazamiento hacia la izquierda
                while i <= 5 and not encontrado:
                    col_candidata = col_nueva - i
                    # Verificar si la columna candidata está dentro del rango válido
                    if 0 <= col_candidata < len(self.matrix[0]):
                        # Verificar si la columna candidata está vacía
                        if self.matrix[self.row_nueva][col_candidata] == 0:
                            # Asignar la columna candidata a la variable col_nueva
                            col_nueva = col_candidata
                            # Cambiar el valor de la variable encontrado a True
                            encontrado = True
                            # Romper el bucle cuando se encuentre una columna vacía
                            break
                    i += 1  
                # Verificar si la nueva posición es válida
                if self.comprobarPosicion(self.row_nueva, col_nueva):
                    self.fichasFila = self.numFichasEnFila(self.row_nueva)
                    if self.numFichasEnFila(self.row_nueva) > 0:
                        # Cambiar el valor del atributo movimiento a 1, indicando que se puede hacer el segundo movimiento
                        self.movimiento = 1           
                    elif self.numFichasEnFila(self.row_nueva) == 0:
                        self.cambiarTurno()    
                    # Mover ficha
                    self.deleteTile(row, col)
                    self.placeTile(self.row_nueva, col_nueva, ficha)
                    return 1
            else:
                # Verificar si la nueva posición es válida
                if self.comprobarPosicion(self.row_nueva, col):
                    self.fichasFila = self.numFichasEnFila(self.row_nueva)
                    if self.numFichasEnFila(self.row_nueva) > 0:
                        # Cambiar el valor del atributo movimiento a 1, indicando que se puede hacer el segundo movimiento
                        self.movimiento = 1           
                    elif self.numFichasEnFila(self.row_nueva) == 0:
                        self.cambiarTurno() 
                    # Mover ficha
                    self.deleteTile(row, col)
                    self.placeTile(self.row_nueva, col, ficha)
                    return 1
        return 0
    
    
    def movimiento2(self, row, col):
        ficha = self.matrix[row][col]
        if ficha not in {1, 2}:
            print("No hay ficha en esa posición, elige otra en la que haya ficha.")
        # Usar el valor de row que se ha pasado como parámetro
        row_nueva = row
        # Creo una variable booleana que indica si el jugador ha llegado al extremo opuesto
        extremo_opuesto = False
        if self.comprobarPosicion(row_nueva, col):
            # Obtener el número de fichas en la fila a la que se movió la ficha en el primer movimiento
            num_fichas_en_fila = self.fichasFila 
            if num_fichas_en_fila == 0: 
                row_nueva = row
            else:
                if(row + num_fichas_en_fila <= 7 and ficha == 1):
                    row_nueva = row + num_fichas_en_fila
                elif(row - num_fichas_en_fila >= 0  and ficha == 2):
                    row_nueva = row - num_fichas_en_fila
                elif(row + num_fichas_en_fila > 7 and ficha == 1):
                    row_nueva = 7
                elif(row - num_fichas_en_fila < 0 and ficha == 2):
                    row_nueva = 0
                else:
                    return 0
            if self.row_nueva == 7 and ficha == 1:
                self.deleteTile(row, col)
                self.placeTile(row_nueva, col, ficha) 
                '''En caso de dar problemas modificar este row_nueva por row + 1'''
                extremo_opuesto = True
            elif self.row_nueva == 0 and ficha == 2:
                self.deleteTile(row, col)
                self.placeTile(row_nueva, col, ficha)
                '''En caso de dar problemas modificar este row_nueva por row - 1'''
                extremo_opuesto = True    
            col_nueva = col
            # Verificar si el jugador no alcanzó el extremo opuesto
            if row_nueva not in [0, len(self.matrix)] and not extremo_opuesto:
                # Verificar si hay ficha en la fila de destino
                if self.matrix[row_nueva][col] != 0:
                    col_candidata = col_nueva
                    # Si hay ficha, desplaza lateralmente hacia la derecha o izquierda
                    # Creo una variable booleana que indique si se ha encontrado una columna vacía
                    encontrado = False
                    i = 1  # Comenzar con el primer desplazamiento
                    while i <= 5 and not encontrado:
                        col_candidata = col_nueva + i
                        # Verificar si la columna candidata está dentro del rango válido
                        if 0 <= col_candidata < len(self.matrix[0]):
                            # Verificar si la columna candidata está vacía
                            if self.matrix[row_nueva][col_candidata] == 0:
                                # Asignar la columna candidata a la variable col_nueva
                                col_nueva = col_candidata
                                # Cambiar el valor de la variable encontrado a True
                                encontrado = True
                                # Romper el bucle cuando se encuentre una columna vacía
                                break
                        i += 1

                    i = 1  # Restablecer el valor de i para el desplazamiento hacia la izquierda
                    while i <= 5 and not encontrado:
                        col_candidata = col_nueva - i
                        # Verificar si la columna candidata está dentro del rango válido
                        if 0 <= col_candidata < len(self.matrix[0]):
                            # Verificar si la columna candidata está vacía
                            if self.matrix[row_nueva][col_candidata] == 0:
                                # Asignar la columna candidata a la variable col_nueva
                                col_nueva = col_candidata
                                # Cambiar el valor de la variable encontrado a True
                                encontrado = True
                                # Romper el bucle cuando se encuentre una columna vacía
                                break
                        i += 1
                    # Verificar si la nueva posición es válida
                    if self.comprobarPosicion(row_nueva, col_nueva):
                        self.fichasFila = self.numFichasEnFila(row_nueva)   
                        # Mover ficha
                        self.deleteTile(row, col)
                        self.placeTile(row_nueva, col_nueva, ficha)
                else:
                    # Verificar si la nueva posición es válida
                    if self.comprobarPosicion(row_nueva, col):
                        self.fichasFila = self.numFichasEnFila(row_nueva)        
                        # Mover ficha
                        self.deleteTile(row, col)
                        self.placeTile(row_nueva, col, ficha)
            # Verificar si la ficha no cae en una fila vacía
            if self.numFichasEnFila(row_nueva) - 1 > 0:
                # Cambiar el valor del atributo movimiento a 1, indicando que se puede hacer el segundo movimiento
                self.movimiento = 0
                if self.turnoExtra == 1:
                    self.turnoExtra = False                                             
            elif self.numFichasEnFila(row_nueva) - 1 == 0:
                self.movimiento = 0
                self.turnoExtra = True
                #SEGUNDO, hacer que solo se pueda 1 vez un turno extra
            if self.turnoExtra == False:
                self.cambiarTurno()  
            return 1
        else:
            return 0

    
    def finJuego(self):
        # Inicializamos las variables que guardan la posición de la ficha más atrasada de cada tipo
        fila_2 = -1
        col_2 = -1
        fila_1 = len (self.matrix) 
        col_1 = len (self.matrix[0])

        # Recorremos el tablero de arriba a abajo para buscar la ficha más atrasada de las fichas 2
        for i in range (len (self.matrix)):
            # Si hay alguna ficha 2 en la fila i, usamos index (2) para obtener su columna
            if 2 in self.matrix [i]:
                j = self.matrix [i].index (2)
                # Si la fila i es mayor que la fila guardada, o si la fila es la misma pero la columna es menor, actualizamos la posición de la ficha más atrasada
                if i > fila_2 or (i == fila_2 and j < col_2):
                    fila_2 = i
                    col_2 = j

        # Recorremos el tablero de abajo a arriba para buscar la ficha más atrasada de las fichas 1
        for i in range (len (self.matrix) - 1, -1, -1):
            # Si hay alguna ficha 1 en la fila i, usamos index (1) para obtener su columna
            if 1 in self.matrix [i]:
                j = self.matrix [i].index (1)
                # Si la fila i es menor que la fila guardada, o si la fila es la misma pero la columna es menor, actualizamos la posición de la ficha más atrasada
                if i < fila_1 or (i == fila_1 and j < col_1):
                    fila_1 = i
                    col_1 = j
        
        if fila_2 < fila_1:
            return True
        return False
        

    def endGame(self) -> int:
        utilidad = self.utility()
        # Va a determinar qué jugador es el ganador.
        if utilidad > 0:
            return 1  # Rojo gana
        elif utilidad < 0:
            return 2  # Negro gana
        else:
            return 0  # Empate
    
    
    def get_content(self,row,col):
        
        contenido = [None]

        if self.matrix[row][col] == 0:
            contenido[0] = "casillavacia"
        elif self.matrix[row][col]  == 1:
            contenido[0] = "casillanegra"
        elif self.matrix[row][col]  == 2:
            contenido[0] = "casillaroja"
                
        return contenido


    def get_html(self):
        element_image = {
            "casillavacia": "./ImagenesCasillasLinja/CasillaVacia.png",
            "casillanegra": "./ImagenesCasillasLinja/CasillaNegra.png",
            "casillaroja": "./ImagenesCasillasLinja/casillaRoja.png"
        }
        height = len(self.matrix)
        width = len(self.matrix[0])

        html_string = "<style> img.game {width: 47px !important; height: 37px !important;}</style><table>"

        for i in range(height):
            new_row = "<tr>"
            for j in range(width):
                content = self.get_content(i, j)
                drawing = element_image[content[0]]
                html = '<td><img class="game" src=%s alt=""></img></td>' % drawing
                new_row += html

            new_row += "</tr>"
            html_string += new_row

        html_string += "</table>"
        return html_string
    
    
    def moveCanBeMade(self, player: int) -> bool:
        for row in range(len(self.matrix)):
            for col in range(len(self.matrix[0])):
                if self.comprobarPosicion(row, col) and self.matrix[row][col] == player:
                    return True
        return False
    
    
    # def generateSuccessors(self, player):
    #         successors = []
    #         for row in range(len(self.matrix)):
    #             for col in range(len(self.matrix[0])):
                
    #                 if self.matrix[row][col] == player:
                
    #                     # Copia del tablero original
    #                     tablero_copy = Tablerolinja(self.matrix)  
    #                     if tablero_copy.moverFicha(row, col) == 1:                       
    #                         successors.append(tablero_copy)
    #                         for row in range(len(self.matrix)):
    #                             for col in range(len(self.matrix[0])):    
    #                                 # # Copia del tablero original 
    #                                 # tablero_copy = deepcopy(tablero)  

    #                                 # Actualizar turno
    #                                 # tablero_copy.turno = player
                                    
    #                                 # Simular movimiento 2 
    #                                 tablero_copy.movimiento = 1
    #                                 if tablero_copy.moverFicha(row, col) == 1: 
    #                                     successors.append(tablero_copy)
    #                                     print(len(successors))
    #                     if len(successors) == 6:
    #                         break
    #         return successors  
    
    def generateSuccessors(self, playerID: int):
        successors = []
        for row in range(len(self.matrix)):
            for col in range(len(self.matrix[0])):
                tablero_copy = Tablerolinja(self.matrix)  
                if(playerID==2):
                    tablero_copy.changePlayer()
                #copied_board.toString()
                if tablero_copy.comprobarPosicion(row, col):
                    tablero_copy.moverFicha(row, col)
                    for row_ in range(len(self.matrix)):
                        for col_ in range(len(self.matrix[0])):
                            copied_board_2 = copy.deepcopy(tablero_copy)  
                            if copied_board_2.comprobarPosicion(row_, col_):
                                copied_board_2.moverFicha(row_, col_)
                                if(len(successors)==5):
                                    break
                                successors.append(copied_board_2)
        return successors  

    
    def toString(self):
        for i in range (0,8):
            print(self.matrix[i])
        print("")
